open Ast

let parse (s : string) : expr =
  let lexbuf = Lexing.from_string s in
  let ast = Parser.program Lexer.read lexbuf in
  ast
;;

let is_value e =
  match e with
  | Int _ -> true
  | Instruction _ -> true
  | Binop _ -> false
;;

let pp_instruction i =
  match i with
  | Adc -> "ADC"
  | And -> "AND"
  | Asl -> "ASL"
  | Bcc -> "BCC"
  | Bcs -> "BCS"
  | Beq -> "BEQ"
  | Bit -> "BIT"
  | Bmi -> "BMI"
  | Bne -> "BNE"
  | Bpl -> "BPL"
  | Brk -> "BRK"
  | Bvc -> "BVC"
  | Bvs -> "BVS"
  | Clc -> "CLC"
  | Cld -> "CLD"
  | Cli -> "CLI"
  | Clv -> "CLV"
  | Cmp -> "CMP"
  | Cpx -> "CPX"
  | Cpy -> "CPY"
  | Dec -> "DEC"
  | Dex -> "DEX"
  | Dey -> "DEY"
  | Eor -> "EOR"
  | Inc -> "INC"
  | Inx -> "INX"
  | Iny -> "INY"
  | Jmp -> "JMP"
  | Jsr -> "JSR"
  | Lda -> "LDA"
  | Ldx -> "LDX"
  | Ldy -> "LDY"
  | Lsr -> "LSR"
  | Nop -> "NOP"
  | Ora -> "ORA"
  | Pha -> "PHA"
  | Php -> "PHP"
  | Pla -> "PLA"
  | Plp -> "PLP"
  | Rol -> "ROL"
  | Ror -> "ROR"
  | Rti -> "RTI"
  | Rts -> "RTS"
  | Sbc -> "SBC"
  | Sec -> "SEC"
  | Sed -> "SED"
  | Sei -> "SEI"
  | Sta -> "STA"
  | Stx -> "STX"
  | Sty -> "STY"
  | Tax -> "TAX"
  | Tay -> "TAY"
  | Tsx -> "TSX"
  | Txa -> "TXA"
  | Txs -> "TXS"
  | Tya -> "TYA"
;;

let pp_addressing_mod a =
  match a with
  | Accumulator -> Printf.sprintf "A ; ACCUMULATOR"
  | Immediate i -> Printf.sprintf "#$%X ; IMMEDIATE" i
  | Absolute i -> Printf.sprintf "$%X ; ABSOLUTE" i
  | Zeropage i -> Printf.sprintf "$%X ; ZEROPAGE" i
  | AbsoluteX i -> Printf.sprintf "$%X,X ; ABSOLUTE,X" i
  | ZeropageX i -> Printf.sprintf "$%X,X ; ZEROPAGE,X" i
  | AbsoluteY i -> Printf.sprintf "$%X,Y ; ABSOLUTE,Y" i
  | ZeropageY i -> Printf.sprintf "$%X,Y ; ZEROPAGE,Y" i
  | PreIndexIndirect i -> Printf.sprintf "($%X,X) ; (INDIRECT,X)" i
  | PostIndexIndirect i -> Printf.sprintf "($%X),Y; (INDIRECT),Y" i
  (* | Implied -> Printf.sprintf " ; IMPLIED" *)
  | Implied -> Printf.sprintf " ; IMPLIED"
  | Indirect i -> Printf.sprintf "($%X) ; INDIRECT" i
  | Relative i -> Printf.sprintf "$%X ; RELATIVE" i
;;

let string_of_val e =
  match e with
  | Int i -> string_of_int i
  | Instruction (inst, a) -> pp_instruction inst ^ " " ^ pp_addressing_mod a
  | Binop _ -> failwith "Must be a value"
;;

let rec step e =
  match e with
  | Int _ -> failwith "No more steps"
  | Instruction _ -> failwith "No more steps"
  | Binop (op, e1, e2) when is_value e1 && is_value e2 -> step_binop op e1 e2
  | Binop (op, e1, e2) when is_value e1 -> Binop (op, e1, step e2)
  | Binop (op, e1, e2) -> Binop (op, step e1, e2)

and step_binop bop v1 v2 =
  match bop, v1, v2 with
  | Add, Int i1, Int i2 -> Int (i1 + i2)
  | Add, _, _ -> failwith "Step add add should only work with values"
  | Mult, Int i1, Int i2 -> Int (i1 * i2)
  | Mult, _, _ -> failwith "Step add add should only work with values"
;;

let rec eval e = if is_value e then e else e |> step |> eval
let interp s = s |> parse |> eval |> string_of_val

let pgms =
  [ "22"
  ; "0xF"
  ; "0xFF"
  ; "0xFFF"
  ; "0xFFFF"
  ; "$F"
  ; "$FF"
  ; "$FFF"
  ; "$FFFF"
  ; "33"
  ; "0o123"
  ; "0o77"
  ; "0b110011011"
  ; "%110011011"
  ; "0b11111111"
  ; "22+12"
  ; "5*3"
  ; "1+2+3+4"
  ; "1*2*3*4"
  ; "3+4*5"
  ; "3*4+5"
  ; "3*(4+5)"
  ; "1+2*3+4"
  ; " (1+ 2) *( 3 + 4) "
  ; "NOP"
  ; "LDA #12"
  ; "LDA #0b11111111"
  ; "LDA #$12"
  ; "LDA $12"
  ; "LDA $1212"
  ; "LDA $12,X"
  ; "LDA $1212,X"
  ; "LDA $12,Y"
  ; "LDA $1212,Y"
  ; "LDA ($12,X)"
  ; "LDA ($12),Y"
  ; "ADC #12"
  ; "ADC #0b11111111"
  ; "ADC #$12"
  ; "ADC $12"
  ; "ADC $1212"
  ; "ADC $12,X"
  ; "ADC $1212,X"
  ; "ADC $12,Y"
  ; "ADC $1212,Y"
  ; "ADC ($12,X)"
  ; "ADC ($12),Y"
  ; "AND #12"
  ; "AND #0b11111111"
  ; "AND #$12"
  ; "AND $12"
  ; "AND $1212"
  ; "AND $12,X"
  ; "AND $1212,X"
  ; "AND $12,Y"
  ; "AND $1212,Y"
  ; "AND ($12,X)"
  ; "AND ($12),Y"
  ; "ASL"
  ; "ASL A"
  ; "ASL $12"
  ; "ASL $1212"
  ; "ASL $12,X"
  ; "ASL $1212,X"
  ; "BCC $1212"
  ; "BCS $1212"
  ; "BEQ $1212"
  ; "BIT $12"
  ; "BIT $1212"
  ; "BMI $1212"
  ; "BNE $1212"
  ; "BPL $1212"
  ; "BRK"
  ; "BVC $1212"
  ; "BVS $1212"
  ; "CLC"
  ; "CLD"
  ; "CLI"
  ; "CLV"
  ; "CMP #12"
  ; "CMP #0b11111111"
  ; "CMP #$12"
  ; "CMP $12"
  ; "CMP $1212"
  ; "CMP $12,X"
  ; "CMP $1212,X"
  ; "CMP $12,Y"
  ; "CMP $1212,Y"
  ; "CMP ($12,X)"
  ; "CMP ($12),Y"
  ; "CPX #$12"
  ; "CPX $12"
  ; "CPX $1212"
  ; "CPY #$12"
  ; "CPY $12"
  ; "CPY $1212"
  ; "DEC $12"
  ; "DEC $1212"
  ; "DEC $12,X"
  ; "DEC $1212,X"
  ; "DEX"
  ; "DEY"
  ; "EOR #12"
  ; "EOR #0b11111111"
  ; "EOR #$12"
  ; "EOR $12"
  ; "EOR $1212"
  ; "EOR $12,X"
  ; "EOR $1212,X"
  ; "EOR $12,Y"
  ; "EOR $1212,Y"
  ; "EOR ($12,X)"
  ; "EOR ($12),Y"
  ; "INC $12"
  ; "INC $1212"
  ; "INC $12,X"
  ; "INC $1212,X"
  ; "INX"
  ; "INY"
  ; "JMP $1212"
  ; "JMP ($1212)"
  ; "JSR $1212"
  ; "LDX #12"
  ; "LDX #0b11111111"
  ; "LDX #$12"
  ; "LDX $12"
  ; "LDX $1212"
  ; "LDX $12,Y"
  ; "LDX $1212,Y"
  ; "LDY #12"
  ; "LDY #0b11111111"
  ; "LDY #$12"
  ; "LDY $12"
  ; "LDY $1212"
  ; "LDY $12,X"
  ; "LDY $1212,X"
  ; "LSR"
  ; "LSR A"
  ; "LSR $12"
  ; "LSR $1212"
  ; "LSR $12,X"
  ; "LSR $1212,X"
  ; "ORA #12"
  ; "ORA #0b11111111"
  ; "ORA #$12"
  ; "ORA $12"
  ; "ORA $1212"
  ; "ORA $12,X"
  ; "ORA $1212,X"
  ; "ORA $12,Y"
  ; "ORA $1212,Y"
  ; "ORA ($12,X)"
  ; "ORA ($12),Y"
  ; "PHA"
  ; "PHP"
  ; "PLA"
  ; "PLP"
  ; "ROL"
  ; "ROL A"
  ; "ROL $12"
  ; "ROL $1212"
  ; "ROL $12,X"
  ; "ROL $1212,X"
  ; "ROR"
  ; "ROR A"
  ; "ROR $12"
  ; "ROR $1212"
  ; "ROR $12,X"
  ; "ROR $1212,X"
  ; "RTI"
  ; "RTS"
  ; "SBC #12"
  ; "SBC #0b11111111"
  ; "SBC #$12"
  ; "SBC $12"
  ; "SBC $1212"
  ; "SBC $12,X"
  ; "SBC $1212,X"
  ; "SBC $12,Y"
  ; "SBC $1212,Y"
  ; "SBC ($12,X)"
  ; "SBC ($12),Y"
  ; "SEC"
  ; "SED"
  ; "SEI"
  ; "STA #12"
  ; "STA #0b11111111"
  ; "STA #$12"
  ; "STA $12"
  ; "STA $1212"
  ; "STA $12,X"
  ; "STA $1212,X"
  ; "STA $12,Y"
  ; "STA $1212,Y"
  ; "STA ($12,X)"
  ; "STA ($12),Y"
  ; "STX $12"
  ; "STX $1212"
  ; "STX $12,Y"
  ; "STX $1212,Y"
  ; "STY $12"
  ; "STY $1212"
  ; "STY $12,X"
  ; "STY $1212,X"
  ; "TAX"
  ; "TAY"
  ; "TSX"
  ; "TXA"
  ; "TXS"
  ; "TYA"
  ; "LDA #1+2"
  ]
;;

let () = List.iter (fun pgm -> Printf.printf "%s - %s\n" pgm (interp pgm)) pgms
